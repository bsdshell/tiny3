<html><head><link rel="stylesheet" type="text/css" href="mycss/style.css"/></head><body class="htmlbg"><span class="tit">    [Haskell zip and zipWith]</span><br><span class="keyword">    :zip::[a]-&gt;[b]-&gt;[(a,b)]</span><br>
<pre>        zip <span class="bracket">[</span>1..3<span class="bracket">]</span> <span class="bracket">[</span>1..3<span class="bracket">]</span>  = <span class="bracket">[</span><span class="bracket">(</span>1,1<span class="bracket">)</span><span class="bracket">(</span>2,2<span class="bracket">)</span><span class="bracket">(</span>3,3<span class="bracket">)</span><span class="bracket">]</span> 
</pre>
<span class="tit">    [Haskell zipWith]</span><br>
<pre>        zip<span class="bracket">(</span>\x y->x+y<span class="bracket">)</span><span class="bracket">[</span>1, 2<span class="bracket">]</span> <span class="bracket">[</span>3, 4<span class="bracket">]</span>
        -- output <span class="bracket">[</span>4, 6<span class="bracket">]</span>
</pre>
<span class="tit">    [Haskell zipWith]</span><br>
<pre>        zipWith <span class="bracket">[</span>1, 2<span class="bracket">]</span> <span class="bracket">[</span>3, 4<span class="bracket">]</span>
        -- output <span class="bracket">[</span><span class="bracket">(</span>1, 3<span class="bracket">)</span>, <span class="bracket">(</span>2, 4<span class="bracket">)</span><span class="bracket">]</span>
</pre>
<span class="tit">    [Haskell zipWith]</span><br><span class="keyword">    :zipWith::(a-&gt;b-&gt;c)-&gt;[a]-&gt;[b]-&gt;[c]</span><br>
<pre>        let list1 = <span class="bracket">[</span>1..4<span class="bracket">]</span> 
        let list2 = <span class="bracket">[</span>10..20<span class="bracket">]</span> 
        zipWith <span class="bracket">(</span>\x y -> x+y<span class="bracket">)</span> list1 list2 
</pre>
<span class="tit">    [hackell cool stuff]</span><br><span class="keyword">    :myfile::String-&gt;String</span><br><span class="tit">    [Haskell uncurry and mapM_]</span><br><span class="keyword">    :zipWith::(a-&gt;b-&gt;c)-&gt;[a]-&gt;[b]-&gt;[c]</span><br>
<pre>        let list1 = <span class="bracket">[</span>"/file1.txt", "/fil2.txt"<span class="bracket">]</span>
        let list2 = <span class="bracket">[</span>"/tmp/name1.txt", "/tmp/name2.txt"<span class="bracket">]</span>
        mapM_ <span class="bracket">(</span>uncurry copyFile<span class="bracket">)</span> $ zip list1 list2 
</pre>
<span class="tit">    [Haskell curry]</span><br><span class="keyword">    :curry::(a,b)-&gt;c-&gt;a-&gt;b-&gt;c</span><br>    convert uncurried function to curried function 
<pre>        let c = \<span class="bracket">(</span>x, y<span class="bracket">)</span>-> x + y
        curry c 1 2   -- output 3 
</pre>
<span class="tit">    [Haskell uncurry]</span><br><span class="keyword">    :uncurry::a-&gt;b-&gt;c-&gt;(a,b)-&gt;c</span><br>    convert curried function to uncurried function
<pre>        mapM_<span class="bracket">(</span>uncurry copyFile<span class="bracket">)</span> $ zip list1 list2 
        let un = \x y -> x*y
        uncurry un <span class="bracket">(</span>2, 3<span class="bracket">)</span>   -- output 6
</pre>
<span class="tit">    [Haskell subRegex]</span><br><span class="keyword">    :subRegex::Regex-&gt;input-&gt;replacement-&gt;output</span><br>
<pre>        subRegex<span class="bracket">(</span>mkRegex "/dog/"<span class="bracket">)</span> "the dog" "cat\0"
        -- output "that catdog"
</pre>
<span class="tit">    [Haskell merge two lists]</span><br>
<pre>        <span class="bracket">mergeList::</span><span class="bracket">[</span>String<span class="bracket">]</span>-><span class="bracket">[</span>String<span class="bracket">]</span>-><span class="bracket">[</span>String<span class="bracket">]</span>
        mergeList <span class="bracket">[</span><span class="bracket">]</span> <span class="bracket">[</span><span class="bracket">]</span> = <span class="bracket">[</span><span class="bracket">]</span>
        mergeList  l  <span class="bracket">[</span><span class="bracket">]</span> = l 
        mergeList <span class="bracket">[</span><span class="bracket">]</span>  r = r 
        mergeList <span class="bracket">(</span>x:xs<span class="bracket">)</span> <span class="bracket">(</span>y:ys<span class="bracket">)</span> = x:y:mergeList xs ys
</pre>
<span class="tit">    [Haskell merge two sorted lists]</span><br>
<pre>        <span class="bracket">mergeSortList::</span><span class="bracket">[</span>Int<span class="bracket">]</span>-><span class="bracket">[</span>Int<span class="bracket">]</span>-><span class="bracket">[</span>Int<span class="bracket">]</span>
        mergeSortList <span class="bracket">[</span><span class="bracket">]</span> r          = r
        mergeSortList l <span class="bracket">[</span><span class="bracket">]</span>          = l
        mergeSortList <span class="bracket">(</span>x:xs<span class="bracket">)</span> <span class="bracket">(</span>y:ys<span class="bracket">)</span> = if x < y then x:<span class="bracket">(</span>mergeSortList xs <span class="bracket">(</span>y:ys<span class="bracket">)</span><span class="bracket">)</span> else y:<span class="bracket">(</span>mergeSortList <span class="bracket">(</span>x:xs<span class="bracket">)</span> ys<span class="bracket">)</span>
</pre>
<span class="tit">    [Haskell merge two lists with Maybe]</span><br>
<pre>        <span class="bracket">mergeList2::</span><span class="bracket">[</span>a<span class="bracket">]</span>-><span class="bracket">[</span>a<span class="bracket">]</span>->Maybe <span class="bracket">[</span>a<span class="bracket">]</span>
        mergeList2 <span class="bracket">[</span><span class="bracket">]</span> <span class="bracket">[</span><span class="bracket">]</span> = Just <span class="bracket">[</span><span class="bracket">]</span> 
        mergeList2 <span class="bracket">(</span>x:xs<span class="bracket">)</span> <span class="bracket">(</span>y:ys<span class="bracket">)</span> = 
                    case mergeList2 xs ys of
                    Just merged -> Just <span class="bracket">(</span>x:y:merged<span class="bracket">)</span>
                    Nothing  -> Nothing
        mergeList2 _ _  = Nothing
</pre>
<span class="tit">    [Haskell Quick Sort]</span><br>
<pre>        <span class="bracket">quickSort::</span><span class="bracket">[</span>Int<span class="bracket">]</span>-><span class="bracket">[</span>Int<span class="bracket">]</span>
        quickSort <span class="bracket">[</span><span class="bracket">]</span> = <span class="bracket">[</span><span class="bracket">]</span>
        quickSort <span class="bracket">[</span>x<span class="bracket">]</span> = <span class="bracket">[</span>x<span class="bracket">]</span>
        quickSort l = quickSort<span class="bracket">(</span>left<span class="bracket">)</span> ++ p:<span class="bracket">[</span><span class="bracket">]</span> ++ quickSort right 
                            where
                                left =  <span class="bracket">[</span>x | x <- init l, x < p<span class="bracket">]</span>
                                right = <span class="bracket">[</span>x | x <- init l, x >= p<span class="bracket">]</span>
                                p = last l 
</pre>
<span class="tit">    [Haskell Merge Sort]</span><br>
<pre>        <span class="bracket">mergeSort::</span><span class="bracket">[</span>Int<span class="bracket">]</span>-><span class="bracket">[</span>Int<span class="bracket">]</span>
        mergeSort <span class="bracket">[</span><span class="bracket">]</span> = <span class="bracket">[</span><span class="bracket">]</span>
        mergeSort <span class="bracket">[</span>x<span class="bracket">]</span> = <span class="bracket">[</span>x<span class="bracket">]</span>
        mergeSort l = merge<span class="bracket">(</span>mergeSort left<span class="bracket">)</span> <span class="bracket">(</span>mergeSort right<span class="bracket">)</span> 
                        where
                            half = <span class="bracket">(</span>length l<span class="bracket">)</span> `div` 2
                            left = take half l
                            right = drop half l  

                            <span class="bracket">merge::</span><span class="bracket">[</span>Int<span class="bracket">]</span>-><span class="bracket">[</span>Int<span class="bracket">]</span>-><span class="bracket">[</span>Int<span class="bracket">]</span>
                            merge <span class="bracket">[</span><span class="bracket">]</span> r = r
                            merge l <span class="bracket">[</span><span class="bracket">]</span> = l
                            merge <span class="bracket">(</span>x:xs<span class="bracket">)</span> <span class="bracket">(</span>y:ys<span class="bracket">)</span>  = if x < y
                                                    then 
                                                       x:merge xs <span class="bracket">(</span>y:ys<span class="bracket">)</span> 
                                                    else
                                                       y:merge <span class="bracket">(</span>x:xs<span class="bracket">)</span> ys 
</pre>
<span class="tit">    [Haskell split]</span><br>
<pre>        <span class="bracket">split::</span><span class="bracket">[</span>Int<span class="bracket">]</span>-><span class="bracket">(</span><span class="bracket">[</span>Int<span class="bracket">]</span>, <span class="bracket">[</span>Int<span class="bracket">]</span><span class="bracket">)</span>
        split <span class="bracket">[</span><span class="bracket">]</span> = <span class="bracket">(</span><span class="bracket">[</span><span class="bracket">]</span>, <span class="bracket">[</span><span class="bracket">]</span><span class="bracket">)</span> 
        split <span class="bracket">[</span>x<span class="bracket">]</span> = <span class="bracket">(</span><span class="bracket">[</span>x<span class="bracket">]</span>, <span class="bracket">[</span><span class="bracket">]</span><span class="bracket">)</span>
        split <span class="bracket">(</span>x:y:rest<span class="bracket">)</span> = <span class="bracket">(</span>x:xs, y:xy<span class="bracket">)</span>   
                        where
                            <span class="bracket">(</span>xs, xy<span class="bracket">)</span> = split rest
        -- split <span class="bracket">[</span>1,2,3<span class="bracket">]</span>  = <span class="bracket">(</span><span class="bracket">[</span>1,3<span class="bracket">]</span>, <span class="bracket">[</span>2<span class="bracket">]</span><span class="bracket">)</span>
        -- split <span class="bracket">[</span>1,2,3,4<span class="bracket">]</span>  = <span class="bracket">(</span><span class="bracket">[</span>1,3<span class="bracket">]</span>, <span class="bracket">[</span>2,4<span class="bracket">]</span><span class="bracket">)</span>
</pre>
<span class="tit">    [Haskell check array]</span><br>
<pre>        check sum<span class="bracket">(</span>x_0, x_1,...,x_k<span class="bracket">)</span> == sum<span class="bracket">(</span>x_k+1,...,x_n<span class="bracket">)</span>

        <span class="bracket">checkSum::</span><span class="bracket">[</span>Int<span class="bracket">]</span>->Int->Bool
        checkSum <span class="bracket">[</span><span class="bracket">]</span>  _ = True
        checkSum <span class="bracket">[</span>x<span class="bracket">]</span> _ = x    =  = 0
        checkSum l inx | sum<span class="bracket">(</span>take inx l<span class="bracket">)</span> == sum<span class="bracket">(</span>drop inx l<span class="bracket">)</span> = True
                       | inx <= length l = checkSum l <span class="bracket">(</span>inx+1<span class="bracket">)</span>
                       | otherwise       = False

</pre>
<span class="tit">    [Haskell check array 2]</span><br>
<pre>        -- check sum<span class="bracket">(</span>x_0, x_1,...,x_k<span class="bracket">)</span> == sum<span class="bracket">(</span>x_k+1,...,x_n<span class="bracket">)</span>

        -- import Data.List<span class="bracket">(</span>inits, tails<span class="bracket">)</span>
        <span class="bracket">checkSum2::</span><span class="bracket">[</span>Int<span class="bracket">]</span>->Bool
        checkSum2 xs | len > 0 = True 
                    | otherwise = False
                    where
                        len = length $ filter<span class="bracket">(</span>\x-> sum <span class="bracket">(</span>fst x<span class="bracket">)</span> == sum <span class="bracket">(</span>snd x<span class="bracket">)</span><span class="bracket">)</span> $ splits xs
                        <span class="bracket">splits::</span><span class="bracket">[</span>a<span class="bracket">]</span> -> <span class="bracket">[</span><span class="bracket">(</span><span class="bracket">[</span>a<span class="bracket">]</span>, <span class="bracket">[</span>a<span class="bracket">]</span><span class="bracket">)</span><span class="bracket">]</span>
                        splits xs = zip <span class="bracket">(</span>inits xs<span class="bracket">)</span> <span class="bracket">(</span>tails xs<span class="bracket">)</span> 

</pre>
<span class="tit">    [Haskell check array 3]</span><br>
<pre>        -- check sum<span class="bracket">(</span>x_0, x_1,...,x_k<span class="bracket">)</span> == sum<span class="bracket">(</span>x_k+1,...,x_n<span class="bracket">)</span>

        <span class="bracket">checkSum4::</span><span class="bracket">[</span>Int<span class="bracket">]</span> -> Bool
        checkSum4 a = go a 0 <span class="bracket">(</span>sum a<span class="bracket">)</span>
           where go <span class="bracket">[</span><span class="bracket">]</span> left right = left==right
                 go <span class="bracket">(</span>x:xs<span class="bracket">)</span> left right | left==right = True
                                      | otherwise = go xs <span class="bracket">(</span>left+x<span class="bracket">)</span> <span class="bracket">(</span>right-x<span class="bracket">)</span>
</pre>
 <div class="cen"><img src=image/manhattan.png width="60%" height="60%"></div> <span class="tit">    [Haskell Matrix Multiplication]</span><br>
<pre>        m1 = <span class="bracket">[</span><span class="bracket">[</span>1, 2<span class="bracket">]</span>, 
              <span class="bracket">[</span>3, 4<span class="bracket">]</span>
             <span class="bracket">]</span>
        m2 = <span class="bracket">[</span><span class="bracket">[</span>5, 7<span class="bracket">]</span>, 
              <span class="bracket">[</span>8, 9<span class="bracket">]</span>
             <span class="bracket">]</span>

        <span class="bracket">mmult::</span><span class="bracket">[</span><span class="bracket">[</span>Int<span class="bracket">]</span><span class="bracket">]</span> -> <span class="bracket">[</span><span class="bracket">[</span>Int<span class="bracket">]</span><span class="bracket">]</span> -> <span class="bracket">[</span><span class="bracket">[</span>Int<span class="bracket">]</span><span class="bracket">]</span> 
        mmult a b = <span class="bracket">[</span> <span class="bracket">[</span> sum $ zipWith <span class="bracket">(</span>*<span class="bracket">)</span> ar bc | bc <- <span class="bracket">(</span>transpose b<span class="bracket">)</span> <span class="bracket">]</span> | ar <- a <span class="bracket">]</span>
</pre>
 <span class="tit">    [vim command]</span><br><span class="keyword">    :/\(if\)\ze\(then\)         </span><span class="comment">// if follows then "[if]then"</span><br><span class="keyword">    :/\(if\)\zs\(then\)         </span><span class="comment">// then starts with if "if[then]" </span><br><span class="tit">    [Vim Script get background color]</span><br>
<pre>         :echo synIDattr<span class="bracket">(</span>synIDtrans<span class="bracket">(</span>hlID<span class="bracket">(</span>"Normal"<span class="bracket">)</span><span class="bracket">)</span>, "bg"<span class="bracket">)</span> <span class="bracket">[</span>:h hlID<span class="bracket">]</span>       
</pre>
<span class="tit">    [Linux command]</span><br>    git branch shows on command prompt
<pre>        parse_<span class="bracket">git</span>_branch<span class="bracket">(</span><span class="bracket">)</span><span class="bracket">{</span>
            <span class="bracket">git</span> branch 2> /dev/null | sed -e 's/* \<span class="bracket">(</span>.*\<span class="bracket">)</span>/ \<span class="bracket">(</span>\1<span class="bracket">)</span>/'
        <span class="bracket">}</span>
        export PS1="\u$<span class="bracket">(</span>parse_<span class="bracket">git</span>_branch<span class="bracket">)</span>\w$"
        \u - Username
        \w - Full path
        \h - Host name
</pre>
     <div class="cen"><img src=image/manhattan.png width="60%" height="60%"></div>
</body></html>